import sqlite3
from matplotlib.colors import ListedColormap
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib as mpl

#python playground for processing and displaying the out.sql file generated by 
#the C code. 

order_avg = np.empty((0,), dtype=float)
edge_prob_avg = np.empty((0,), dtype=float)
prop_avg = np.empty((0,), dtype=float)

# Connect to the SQLite database
conn = sqlite3.connect("out.db")
cursor = conn.cursor()

TABLES = ["samples_1", "samples_2", "samples_3", "samples_4", "samples_5", "samples_6", "samples_7", "samples_8", "samples_9"]

for t in TABLES:
  # Fetch all columns in the table
  try:
    cursor.execute(f"PRAGMA table_info({t})")
  except:
    continue # table does not exist, ignore
  columns = [col[1] for col in cursor.fetchall()]

  # Separate columns by category
  order_columns = [col for col in columns if col.startswith("n_")]
  edge_prob_columns = [col for col in columns if col.startswith("p_")]
  prop_columns = [col for col in columns if col.startswith("property_")]

  print(order_columns, edge_prob_columns, prop_columns)

  # Query the data and calculate averages for each category
  try:
    cursor.execute(f"SELECT * FROM({t})")
  except:
    continue # table does not exist, ignore
  rows = cursor.fetchall()

  # Convert rows to a NumPy array for easier manipulation
  data = np.array(rows)

  # Calculate averages across columns in each category

  order_avg = np.concatenate((order_avg, np.mean(data[:, [columns.index(col) for col in order_columns]], axis=1)))
  edge_prob_avg = np.concatenate((edge_prob_avg, np.mean(data[:, [columns.index(col) for col in edge_prob_columns]], axis=1)))
  prop_avg = np.concatenate((prop_avg, np.mean(data[:, [columns.index(col) for col in prop_columns]], axis=1)))
conn.close()

# Create a custom colormap emphasizing the minimum
colors = mpl.colormaps['viridis'](np.linspace(0, 1, 100))  # Start with 'viridis'
colors[0] = [0, 1, 0, 0.0]
colors[1] = [0, 1, 0, 0.0]
custom_cmap = ListedColormap(colors)

# Find the normalized color for edges_avg
min_val = 1
max_val = np.max(1.0)
norm = plt.Normalize(vmin=0.0, vmax=1.0)


# Create the 3D plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

prop_avg /= np.max(prop_avg)

sc = ax.scatter(order_avg, edge_prob_avg, prop_avg, s=0.01, c=prop_avg, cmap=custom_cmap, norm=norm, marker='s')


# Set labels
ax.set_xlabel("Order")
ax.set_ylabel("Edge Probability")
ax.set_zlabel("Components (Sample Mean)")
#plt.colorbar(sc, label="Components (Sample Mean)")

ax.view_init(elev=30, azim=45)

# Show the plot
#plt.show()

#plt.savefig("numcomponents-angle.png", format="png", dpi=300)


ax.view_init(elev=0, azim=0)

#plt.savefig("numcomponents-p.png", format="png", dpi=300)

ax.view_init(elev=0, azim=90)

#plt.savefig("numcomponents-n.png", format="png", dpi=300)

ax.view_init(elev=90, azim=180)

#plt.savefig("numcomponents-np.png", format="png", dpi=300)



from scipy import optimize

# Define the model
def model1(x, a, b, c, d):
    return a * np.exp(b * (x - c)) + d
def model2(x, a, b, c, d):
    return (a * x + b)/(c * x + d)
model = model2

# Define the custom loss function based on the conditions you want to minimize
def loss(params, x, y, z):
    a, b, c, d = params
    predicted_y = model(x, a, b, c, d)
    return loss_general(x, y, z, predicted_y)

import math

def loss_general(x, y, z, predicted_y):
    # Compute the error
    error = 0
    
    for i in range(len(x)):
        if x[i] < 1: continue
        if z[i] == 1:
            # Penalize when y < predicted_y (for z = 1)
            if y[i] < predicted_y[i]:
                error += (predicted_y[i] - y[i]) ** 2
        elif z[i] > 1:
            # Penalize when y > predicted_y (for z > 1)
            if y[i] > predicted_y[i]:
                error += (predicted_y[i] - y[i]) ** 2
                
    return error


INITIAL_VALUES = [0, 1, 1, 1]

result = optimize.minimize(loss, INITIAL_VALUES, args=(order_avg, edge_prob_avg, prop_avg))

params_old = (0.0030689107603127496, 2.654104752450767, 0.2969174200192246, 1.8914861703748291)
a_old, b_old, c_old, d_old = params_old

a_opt, b_opt, c_opt, d_opt = result.x
#print("Optimized parameters:")
#print(f"a = {a_opt}, b = {b_opt}, c = {c_opt}, d = {d_opt}")
#print(f"Error: {result.fun}")

#print(f"Old error: {loss(params_old, order_avg, edge_prob_avg, prop_avg)}")

#print(a_opt - a_old, b_opt - b_old, c_opt - c_old, d_opt - d_old)

x_curve:np.ndarray = np.linspace(np.min(order_avg), np.max(order_avg), 100)
y_curve:np.ndarray = model(x_curve, a_opt, b_opt, c_opt, d_opt)
y_old:np.ndarray = model(x_curve, a_old, b_old, c_old, d_old)

# Plot the fitted curve
#ax.plot(x_curve, y_curve, np.zeros_like(x_curve), color='green', label='Fitted curve')
ax.plot(x_curve, y_old, np.zeros_like(x_curve), color='red', label='Old Fitted curve')

#plt.savefig("numcomponents-r.png")
#plt.show()
"""
import math

def attempt(x:int, y:float):
  P = 0.0
  x = int(x)
  for i in range(1, x):
    for j in range(0, x - i):
      P += math.pow(y, x - i - j) * math.pow((1 - math.pow(1 - y, i - 1)) * (1 - math.pow(y, i - 1)), j)
  return P

# Function to solve: find y such that attempt(x, y) = 1
def equation(y, x):
    return attempt(x, y) - 1  # We want to find y where this equals 0

# Initialize array to store the corresponding y values
y_curve = []

# Solve for y for each x
for x in x_curve:
    # Use fsolve to find the root of equation(y, x) = 0
    # Initial guess for y, start with y = 0.5
    y_solution = optimize.fsolve(equation, 0.5, args=(x,))
    y_curve.append(y_solution[0])  # Extract the first solution
    print("optimized ", x)

def pred_model(x):
   return np.interp(x, x_curve, y_curve)

print("model loss: ", loss_general(order_avg, edge_prob_avg, prop_avg, pred_model(order_avg)))

ax.plot(x_curve, y_curve, np.zeros_like(x_curve), color='green', label='P = 1.0')

plt.savefig("numcomponents-rmodel.png")
"""

def attempt2(x:np.ndarray, a, b, c, d):
  return (np.log(a * x - b) + c) / (a * x - b) + d
model = attempt2

INITIAL_VALUES = [2, 2, 1, 1]
result:optimize.OptimizeResult = optimize.minimize(loss, INITIAL_VALUES, args=(order_avg, edge_prob_avg, prop_avg))
(a_opt, b_opt, c_opt, d_opt) = result.x

y_curve = model(x_curve[1:], a_opt, b_opt, c_opt, d_opt)
ax.plot(x_curve[1:], y_curve, np.zeros_like(x_curve[1:]), color="orange", label='Fitted p*')
print(y_curve)

print("Optimized parameters:")
print(f"a = {a_opt}, b = {b_opt}, c = {c_opt}, d = {d_opt}")
print(f"Error: {result.fun}")

#plt.savefig("numcomponents-r.png")
plt.show()